<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "8da1b5e2c63f749808858c53f37b8ce7",
  "translation_date": "2025-08-26T00:30:25+00:00",
  "source_file": "7-bank-project/1-template-route/README.md",
  "language_code": "ur"
}
-->
# بینکنگ ایپ بنائیں حصہ 1: ویب ایپ میں HTML ٹیمپلیٹس اور روٹس

## لیکچر سے پہلے کا کوئز

[لیکچر سے پہلے کا کوئز](https://ashy-river-0debb7803.1.azurestaticapps.net/quiz/41)

### تعارف

جب سے براؤزرز میں جاوا اسکرپٹ آیا ہے، ویب سائٹس پہلے سے زیادہ انٹرایکٹو اور پیچیدہ ہو گئی ہیں۔ ویب ٹیکنالوجیز اب عام طور پر مکمل طور پر فعال ایپلیکیشنز بنانے کے لیے استعمال ہوتی ہیں جو براہ راست براؤزر میں چلتی ہیں، جنہیں ہم [ویب ایپلیکیشنز](https://en.wikipedia.org/wiki/Web_application) کہتے ہیں۔ چونکہ ویب ایپس بہت زیادہ انٹرایکٹو ہوتی ہیں، صارفین ہر بار کسی ایکشن کے انجام دینے پر پورے صفحے کو دوبارہ لوڈ کرنے کا انتظار نہیں کرنا چاہتے۔ اسی لیے جاوا اسکرپٹ HTML کو براہ راست DOM کے ذریعے اپ ڈیٹ کرنے کے لیے استعمال کیا جاتا ہے، تاکہ صارفین کو ہموار تجربہ فراہم کیا جا سکے۔

اس سبق میں، ہم بینک ویب ایپ بنانے کے لیے بنیادیں رکھیں گے، HTML ٹیمپلیٹس کا استعمال کرتے ہوئے متعدد اسکرینز بنائیں گے جنہیں پورے HTML صفحے کو دوبارہ لوڈ کیے بغیر دکھایا اور اپ ڈیٹ کیا جا سکتا ہے۔

### پیشگی شرط

آپ کو اس سبق میں بنائی گئی ویب ایپ کو ٹیسٹ کرنے کے لیے ایک مقامی ویب سرور کی ضرورت ہوگی۔ اگر آپ کے پاس نہیں ہے، تو آپ [Node.js](https://nodejs.org) انسٹال کر سکتے ہیں اور اپنے پروجیکٹ فولڈر سے کمانڈ `npx lite-server` استعمال کر سکتے ہیں۔ یہ ایک مقامی ویب سرور بنائے گا اور آپ کی ایپ کو براؤزر میں کھولے گا۔

### تیاری

اپنے کمپیوٹر پر `bank` نامی ایک فولڈر بنائیں اور اس کے اندر `index.html` نامی فائل رکھیں۔ ہم اس HTML [بوائلر پلیٹ](https://en.wikipedia.org/wiki/Boilerplate_code) سے شروع کریں گے:

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bank App</title>
  </head>
  <body>
    <!-- This is where you'll work -->
  </body>
</html>
```

---

## HTML ٹیمپلیٹس

اگر آپ کسی ویب صفحے کے لیے متعدد اسکرینز بنانا چاہتے ہیں، تو ایک حل یہ ہوگا کہ آپ ہر اسکرین کے لیے ایک HTML فائل بنائیں جسے آپ دکھانا چاہتے ہیں۔ تاہم، اس حل میں کچھ مشکلات ہیں:

- اسکرین تبدیل کرتے وقت پورے HTML کو دوبارہ لوڈ کرنا پڑتا ہے، جو کہ سست ہو سکتا ہے۔
- مختلف اسکرینز کے درمیان ڈیٹا شیئر کرنا مشکل ہوتا ہے۔

ایک اور طریقہ یہ ہے کہ صرف ایک HTML فائل ہو، اور متعدد [HTML ٹیمپلیٹس](https://developer.mozilla.org/docs/Web/HTML/Element/template) کو `<template>` عنصر کا استعمال کرتے ہوئے ڈیفائن کریں۔ ایک ٹیمپلیٹ ایک قابل استعمال HTML بلاک ہے جو براؤزر کے ذریعے ظاہر نہیں کیا جاتا، اور اسے جاوا اسکرپٹ کے ذریعے رن ٹائم پر انسٹیٹیوٹ کرنا پڑتا ہے۔

### کام

ہم ایک بینک ایپ بنائیں گے جس میں دو اسکرینز ہوں گی: لاگ ان صفحہ اور ڈیش بورڈ۔ پہلے، HTML باڈی میں ایک پلیس ہولڈر عنصر شامل کریں گے جسے ہم اپنی ایپ کی مختلف اسکرینز انسٹیٹیوٹ کرنے کے لیے استعمال کریں گے:

```html
<div id="app">Loading...</div>
```

ہم نے اسے `id` دیا ہے تاکہ بعد میں جاوا اسکرپٹ کے ذریعے اسے تلاش کرنا آسان ہو۔

> ٹپ: چونکہ اس عنصر کا مواد تبدیل کیا جائے گا، ہم اس میں ایک لوڈنگ پیغام یا انڈیکیٹر ڈال سکتے ہیں جو ایپ لوڈ ہونے کے دوران دکھایا جائے گا۔

اب، لاگ ان صفحے کے لیے HTML ٹیمپلیٹ کو شامل کریں۔ فی الحال ہم اس میں صرف ایک عنوان اور ایک سیکشن رکھیں گے جس میں ایک لنک ہوگا جسے ہم نیویگیشن کے لیے استعمال کریں گے۔

```html
<template id="login">
  <h1>Bank App</h1>
  <section>
    <a href="/dashboard">Login</a>
  </section>
</template>
```

پھر ہم ڈیش بورڈ صفحے کے لیے ایک اور HTML ٹیمپلیٹ شامل کریں گے۔ اس صفحے میں مختلف سیکشنز ہوں گے:

- ایک ہیڈر جس میں عنوان اور لاگ آؤٹ لنک ہوگا
- بینک اکاؤنٹ کا موجودہ بیلنس
- ٹرانزیکشنز کی فہرست، جو ایک ٹیبل میں دکھائی جائے گی

```html
<template id="dashboard">
  <header>
    <h1>Bank App</h1>
    <a href="/login">Logout</a>
  </header>
  <section>
    Balance: 100$
  </section>
  <section>
    <h2>Transactions</h2>
    <table>
      <thead>
        <tr>
          <th>Date</th>
          <th>Object</th>
          <th>Amount</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </section>
</template>
```

> ٹپ: جب HTML ٹیمپلیٹس بناتے ہیں، اگر آپ دیکھنا چاہتے ہیں کہ یہ کیسا نظر آئے گا، تو آپ `<template>` اور `</template>` لائنز کو `<!-- -->` کے ساتھ تبصرہ کر سکتے ہیں۔

✅ آپ کے خیال میں ہم نے ٹیمپلیٹس پر `id` ایٹریبیوٹس کیوں استعمال کیے؟ کیا ہم کچھ اور جیسے کلاسز استعمال کر سکتے ہیں؟

## جاوا اسکرپٹ کے ساتھ ٹیمپلیٹس دکھانا

اگر آپ اپنی موجودہ HTML فائل کو براؤزر میں آزمائیں، تو آپ دیکھیں گے کہ یہ `Loading...` دکھانے پر رک جاتی ہے۔ اس کی وجہ یہ ہے کہ ہمیں HTML ٹیمپلیٹس کو انسٹیٹیوٹ اور دکھانے کے لیے کچھ جاوا اسکرپٹ کوڈ شامل کرنے کی ضرورت ہے۔

ٹیمپلیٹ کو انسٹیٹیوٹ کرنے کے لیے عام طور پر 3 مراحل ہوتے ہیں:

1. DOM میں ٹیمپلیٹ عنصر کو تلاش کریں، مثال کے طور پر [`document.getElementById`](https://developer.mozilla.org/docs/Web/API/Document/getElementById) کا استعمال کرتے ہوئے۔
2. ٹیمپلیٹ عنصر کو کلون کریں، [`cloneNode`](https://developer.mozilla.org/docs/Web/API/Node/cloneNode) کا استعمال کرتے ہوئے۔
3. اسے DOM میں کسی مرئی عنصر کے تحت منسلک کریں، مثال کے طور پر [`appendChild`](https://developer.mozilla.org/docs/Web/API/Node/appendChild) کا استعمال کرتے ہوئے۔

✅ ہمیں ٹیمپلیٹ کو DOM میں منسلک کرنے سے پہلے کلون کرنے کی ضرورت کیوں ہے؟ آپ کے خیال میں اگر ہم اس مرحلے کو چھوڑ دیں تو کیا ہوگا؟

### کام

اپنے پروجیکٹ فولڈر میں `app.js` نامی ایک نئی فائل بنائیں اور اس فائل کو اپنے HTML کے `<head>` سیکشن میں امپورٹ کریں:

```html
<script src="app.js" defer></script>
```

اب `app.js` میں، ہم ایک نیا فنکشن `updateRoute` بنائیں گے:

```js
function updateRoute(templateId) {
  const template = document.getElementById(templateId);
  const view = template.content.cloneNode(true);
  const app = document.getElementById('app');
  app.innerHTML = '';
  app.appendChild(view);
}
```

یہاں ہم بالکل وہی 3 مراحل انجام دیتے ہیں جو اوپر بیان کیے گئے ہیں۔ ہم `templateId` کے ساتھ ٹیمپلیٹ کو انسٹیٹیوٹ کرتے ہیں، اور اس کے کلون شدہ مواد کو اپنی ایپ کے پلیس ہولڈر میں رکھتے ہیں۔ نوٹ کریں کہ ہمیں `cloneNode(true)` استعمال کرنے کی ضرورت ہے تاکہ ٹیمپلیٹ کے پورے سب ٹری کو کاپی کیا جا سکے۔

اب اس فنکشن کو ٹیمپلیٹ میں سے کسی ایک کے ساتھ کال کریں اور نتیجہ دیکھیں۔

```js
updateRoute('login');
```

✅ اس کوڈ `app.innerHTML = '';` کا مقصد کیا ہے؟ اس کے بغیر کیا ہوتا ہے؟

## روٹس بنانا

جب کسی ویب ایپ کی بات کرتے ہیں، تو ہم *روٹنگ* سے مراد URLs کو مخصوص اسکرینز کے ساتھ میپ کرنا لیتے ہیں جو دکھائی جانی چاہئیں۔ ایک ویب سائٹ جس میں متعدد HTML فائلز ہوں، اس میں یہ خود بخود ہوتا ہے کیونکہ فائل کے راستے URL پر ظاہر ہوتے ہیں۔ مثال کے طور پر، اگر آپ کے پروجیکٹ فولڈر میں یہ فائلز ہوں:

```
mywebsite/index.html
mywebsite/login.html
mywebsite/admin/index.html
```

اگر آپ `mywebsite` کو روٹ کے طور پر لے کر ایک ویب سرور بناتے ہیں، تو URL میپنگ یہ ہوگی:

```
https://site.com            --> mywebsite/index.html
https://site.com/login.html --> mywebsite/login.html
https://site.com/admin/     --> mywebsite/admin/index.html
```

تاہم، ہماری ویب ایپ کے لیے ہم ایک واحد HTML فائل استعمال کر رہے ہیں جس میں تمام اسکرینز موجود ہیں، لہذا یہ ڈیفالٹ رویہ ہماری مدد نہیں کرے گا۔ ہمیں یہ میپ دستی طور پر بنانا ہوگا اور جاوا اسکرپٹ کا استعمال کرتے ہوئے دکھائی جانے والی ٹیمپلیٹ کو اپ ڈیٹ کرنا ہوگا۔

### کام

ہم ایک سادہ آبجیکٹ استعمال کریں گے تاکہ [میپ](https://en.wikipedia.org/wiki/Associative_array) کو URL راستوں اور ہماری ٹیمپلیٹس کے درمیان نافذ کیا جا سکے۔ اس آبجیکٹ کو اپنے `app.js` فائل کے شروع میں شامل کریں۔

```js
const routes = {
  '/login': { templateId: 'login' },
  '/dashboard': { templateId: 'dashboard' },
};
```

اب `updateRoute` فنکشن کو تھوڑا سا تبدیل کریں۔ `templateId` کو براہ راست آرگومنٹ کے طور پر پاس کرنے کے بجائے، ہم پہلے موجودہ URL کو دیکھ کر اسے حاصل کرنا چاہتے ہیں، اور پھر اپنی میپ کا استعمال کرتے ہوئے متعلقہ ٹیمپلیٹ ID ویلیو حاصل کرنا چاہتے ہیں۔ ہم [`window.location.pathname`](https://developer.mozilla.org/docs/Web/API/Location/pathname) کا استعمال کر سکتے ہیں تاکہ URL سے صرف راستے کا سیکشن حاصل کیا جا سکے۔

```js
function updateRoute() {
  const path = window.location.pathname;
  const route = routes[path];

  const template = document.getElementById(route.templateId);
  const view = template.content.cloneNode(true);
  const app = document.getElementById('app');
  app.innerHTML = '';
  app.appendChild(view);
}
```

یہاں ہم نے اعلان کردہ روٹس کو متعلقہ ٹیمپلیٹ کے ساتھ میپ کیا۔ آپ اسے آزما سکتے ہیں کہ یہ صحیح کام کرتا ہے یا نہیں، براؤزر میں URL کو دستی طور پر تبدیل کر کے۔

✅ اگر آپ URL میں کوئی نامعلوم راستہ درج کریں تو کیا ہوتا ہے؟ ہم اسے کیسے حل کر سکتے ہیں؟

## نیویگیشن شامل کرنا

ہماری ایپ کا اگلا مرحلہ یہ ہے کہ صفحات کے درمیان نیویگیٹ کرنے کی صلاحیت شامل کریں بغیر URL کو دستی طور پر تبدیل کیے۔ اس میں دو چیزیں شامل ہیں:

1. موجودہ URL کو اپ ڈیٹ کرنا
2. نئے URL کی بنیاد پر دکھائی جانے والی ٹیمپلیٹ کو اپ ڈیٹ کرنا

ہم نے پہلے ہی دوسرے حصے کا خیال `updateRoute` فنکشن کے ساتھ رکھا ہے، لہذا ہمیں موجودہ URL کو اپ ڈیٹ کرنے کا طریقہ معلوم کرنا ہوگا۔

ہمیں جاوا اسکرپٹ اور خاص طور پر [`history.pushState`](https://developer.mozilla.org/docs/Web/API/History/pushState) کا استعمال کرنا ہوگا جو URL کو اپ ڈیٹ کرنے اور براؤزنگ ہسٹری میں ایک نیا اندراج بنانے کی اجازت دیتا ہے، بغیر HTML کو دوبارہ لوڈ کیے۔

> نوٹ: جبکہ HTML اینکر عنصر [`<a href>`](https://developer.mozilla.org/docs/Web/HTML/Element/a) کو خود ہی مختلف URLs کے لیے ہائپر لنکس بنانے کے لیے استعمال کیا جا سکتا ہے، یہ ڈیفالٹ طور پر براؤزر کو HTML کو دوبارہ لوڈ کرنے پر مجبور کرے گا۔ جب کسٹم جاوا اسکرپٹ کے ساتھ روٹنگ کو ہینڈل کرتے ہیں، تو اس رویے کو روکنا ضروری ہے، `preventDefault()` فنکشن کا استعمال کرتے ہوئے کلک ایونٹ پر۔

### کام

آئیے ایک نیا فنکشن بناتے ہیں جسے ہم اپنی ایپ میں نیویگیٹ کرنے کے لیے استعمال کر سکتے ہیں:

```js
function navigate(path) {
  window.history.pushState({}, path, path);
  updateRoute();
}
```

یہ میتھڈ پہلے دیے گئے راستے کی بنیاد پر موجودہ URL کو اپ ڈیٹ کرتا ہے، پھر ٹیمپلیٹ کو اپ ڈیٹ کرتا ہے۔ پراپرٹی `window.location.origin` URL روٹ کو واپس کرتی ہے، جس سے ہمیں دیے گئے راستے سے مکمل URL دوبارہ بنانے کی اجازت ملتی ہے۔

اب جب کہ ہمارے پاس یہ فنکشن ہے، ہم اس مسئلے کا خیال رکھ سکتے ہیں جو ہمارے پاس ہے اگر کوئی راستہ کسی بھی ڈیفائن کردہ روٹ سے میل نہیں کھاتا۔ ہم `updateRoute` فنکشن کو تھوڑا سا تبدیل کریں گے اور اگر ہم کوئی میچ نہیں ڈھونڈ سکتے تو موجودہ روٹ کو موجودہ روٹ میں سے کسی ایک پر واپس لے جائیں گے۔

```js
function updateRoute() {
  const path = window.location.pathname;
  const route = routes[path];

  if (!route) {
    return navigate('/login');
  }

  ...
```

اگر کوئی روٹ نہیں ملتا، تو ہم اب `login` صفحے پر ری ڈائریکٹ کریں گے۔

اب ایک فنکشن بنائیں جو لنک پر کلک کرنے پر URL حاصل کرے، اور براؤزر کے ڈیفالٹ لنک رویے کو روک دے:

```js
function onLinkClick(event) {
  event.preventDefault();
  navigate(event.target.href);
}
```

آئیے نیویگیشن سسٹم کو مکمل کریں اور اپنے HTML میں *Login* اور *Logout* لنکس پر بائنڈنگز شامل کریں۔

```html
<a href="/dashboard" onclick="onLinkClick(event)">Login</a>
...
<a href="/login" onclick="onLinkClick(event)">Logout</a>
```

اوپر دیا گیا `event` آبجیکٹ، `click` ایونٹ کو کیپچر کرتا ہے اور اسے ہمارے `onLinkClick` فنکشن میں پاس کرتا ہے۔

[`onclick`](https://developer.mozilla.org/docs/Web/API/GlobalEventHandlers/onclick) ایٹریبیوٹ کا استعمال کرتے ہوئے `click` ایونٹ کو جاوا اسکرپٹ کوڈ کے ساتھ بائنڈ کریں، یہاں `navigate()` فنکشن کو کال کریں۔

ان لنکس پر کلک کرنے کی کوشش کریں، آپ کو اب اپنی ایپ کی مختلف اسکرینز کے درمیان نیویگیٹ کرنے کے قابل ہونا چاہیے۔

✅ `history.pushState` میتھڈ HTML5 اسٹینڈرڈ کا حصہ ہے اور [تمام جدید براؤزرز](https://caniuse.com/?search=pushState) میں نافذ ہے۔ اگر آپ پرانے براؤزرز کے لیے ویب ایپ بنا رہے ہیں، تو آپ اس API کی جگہ ایک چال استعمال کر سکتے ہیں: راستے سے پہلے ایک [ہیش (`#`)](https://en.wikipedia.org/wiki/URI_fragment) کا استعمال کرتے ہوئے آپ روٹنگ کو نافذ کر سکتے ہیں جو باقاعدہ اینکر نیویگیشن کے ساتھ کام کرتا ہے اور صفحہ کو دوبارہ لوڈ نہیں کرتا، کیونکہ اس کا مقصد صفحے کے اندرونی لنکس بنانا تھا۔

## براؤزر کے بیک اور فارورڈ بٹن کو ہینڈل کرنا

`history.pushState` کا استعمال براؤزر کی نیویگیشن ہسٹری میں نئے اندراجات بناتا ہے۔ آپ اسے براؤزر کے *بیک بٹن* کو تھام کر چیک کر سکتے ہیں، یہ کچھ اس طرح دکھائے گا:

![نیویگیشن ہسٹری کا اسکرین شاٹ](../../../../translated_images/history.7fdabbafa521e06455b738d3dafa3ff41d3071deae60ead8c7e0844b9ed987d8.ur.png)

اگر آپ بیک بٹن پر چند بار کلک کرنے کی کوشش کریں، تو آپ دیکھیں گے کہ موجودہ URL تبدیل ہوتا ہے اور ہسٹری اپ ڈیٹ ہوتی ہے، لیکن وہی ٹیمپلیٹ دکھائی دیتا رہتا ہے۔

اس کی وجہ یہ ہے کہ ایپلیکیشن کو معلوم نہیں ہوتا کہ ہمیں ہر بار ہسٹری تبدیل ہونے پر `updateRoute()` کو کال کرنے کی ضرورت ہے۔ اگر آپ [`history.pushState` دستاویزات](https://developer.mozilla.org/docs/Web/API/History/pushState) کو دیکھیں، تو آپ دیکھ سکتے ہیں کہ اگر اسٹیٹ تبدیل ہو جائے - یعنی ہم کسی مختلف URL پر چلے گئے - تو [`popstate`](https://developer.mozilla.org/docs/Web/API/Window/popstate_event) ایونٹ ٹرگر ہوتا ہے۔ ہم اس مسئلے کو حل کرنے کے لیے اس کا استعمال کریں گے۔

### کام

یہ یقینی بنانے کے لیے کہ براؤزر کی ہسٹری تبدیل ہونے پر دکھائی جانے والی ٹیمپلیٹ اپ ڈیٹ ہو، ہم ایک نیا فنکشن منسلک کریں گے جو `updateRoute()` کو کال کرے گا۔ ہم یہ اپنے `app.js` فائل کے آخر میں کریں گے:

```js
window.onpopstate = () => updateRoute();
updateRoute();
```

> نوٹ: ہم نے یہاں اپنے `popstate` ایونٹ ہینڈلر کو مختصر کرنے کے لیے ایک [ایرو فنکشن](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Functions/Arrow_functions) استعمال کیا، لیکن ایک عام فنکشن بھی اسی طرح کام کرے گا۔

ایرو فنکشنز پر ایک ریفریشر ویڈیو یہاں ہے:

[![ایرو فنکشنز](https://img.youtube.com/vi/OP6eEbOj2sc/0.jpg)](https://youtube.com/watch?v=OP6eEbOj2sc "ایرو فنکشنز")

> 🎥 اوپر دی گئی تصویر پر کلک کریں ایرو فنکشنز کے بارے میں ویڈیو دیکھنے کے لیے۔

اب اپنے براؤزر کے بیک اور فارورڈ بٹن استعمال کرنے کی کوشش کریں، اور چیک کریں کہ اس بار دکھائی جانے والا روٹ صحیح طور پر اپ ڈیٹ ہوتا ہے۔

---

## 🚀 چیلنج

اس ایپ کے کریڈٹس دکھانے کے لیے ایک تیسرے صفحے کے لیے ایک نیا ٹیمپلیٹ اور روٹ شامل کریں۔

## لیکچر کے بعد کا کوئز

[لیکچر کے بعد کا کوئز](https://ashy-river-0debb7803.1.azurestaticapps.net/quiz/42)

## جائزہ اور خود مطالعہ

روٹنگ ویب ڈویلپمنٹ کے حیرت انگیز طور پر مشکل حصوں میں سے ایک ہے، خاص طور پر جب ویب صفحہ ریفریش رویے سے سنگل پیج ایپلیکیشن صفحہ ریفریشز کی طرف بڑھتا ہے۔ [Azure Static Web App سروس](https://docs.microsoft.com/azure/static-web-apps/routes/?WT.mc_id=academic-77807-sagibbon) روٹنگ کو کیسے ہینڈل کرتی ہے اس کے بارے میں تھوڑا پڑھیں۔ کیا آپ وضاحت کر سکتے ہیں کہ اس دستاویز میں بیان کردہ کچھ فیصلے کیوں ضروری ہیں؟

## اسائنمنٹ

[روٹنگ کو بہتر بنائیں](assignment.md)

**ڈسکلیمر**:  
یہ دستاویز AI ترجمہ سروس [Co-op Translator](https://github.com/Azure/co-op-translator) کا استعمال کرتے ہوئے ترجمہ کی گئی ہے۔ ہم درستگی کے لیے کوشش کرتے ہیں، لیکن براہ کرم آگاہ رہیں کہ خودکار ترجمے میں غلطیاں یا غیر درستیاں ہو سکتی ہیں۔ اصل دستاویز کو اس کی اصل زبان میں مستند ذریعہ سمجھا جانا چاہیے۔ اہم معلومات کے لیے، پیشہ ور انسانی ترجمہ کی سفارش کی جاتی ہے۔ ہم اس ترجمے کے استعمال سے پیدا ہونے والی کسی بھی غلط فہمی یا غلط تشریح کے ذمہ دار نہیں ہیں۔